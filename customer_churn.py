# -*- coding: utf-8 -*-
"""Untitled21.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10TwcywFDsYkP1wREmZz2TLET2U4IuMsC
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

import warnings
warnings.filterwarnings('ignore')

# Removing annoying warnings
import sys
import warnings
if not sys.warnoptions:
    warnings.simplefilter("ignore")

"""# Importing the dataset"""

churn=pd.read_csv('Churn_Modelling (1).csv')

"""#  Exploratory Data Analysis"""

churn.head()

churn.tail()

churn.shape

churn.info()

churn.isnull().sum()

"""
The dataset has no missing values."""

# understanding the target
churn['Exited'].value_counts()

churn['HasCrCard'].value_counts()

churn['IsActiveMember'].value_counts()

churn['NumOfProducts'].value_counts()

round(churn.describe(),3).T

churn.dtypes

churn.columns

"""Computing the number of exited and not exited clients:"""

exited = len(churn[churn['Exited'] == 1]['Exited'])
not_exited = len(churn[churn['Exited'] == 0]['Exited'])
exited_perc = round(exited/len(churn)*100,1)
not_exited_perc = round(not_exited/len(churn)*100,1)

print('Number of clients that have exited the program: {} ({}%)'.format(exited, exited_perc))
print('Number of clients that haven\'t exited the program: {} ({}%)'.format(not_exited, not_exited_perc))

"""So, around of 20% of the clients exited the bank, while around 80% stayed. As the goal here is to identify which of the customers are at higher risk to discontinue their services with the bank, we are dealing with a classification problem.

A important point to take into consideration here is that we are dealing with an imbalanced dataset.
"""

country = list(churn['Geography'].unique())
gender = list(churn['Gender'].unique())

print(country)
print(gender)

# Create a Exited string variable to create the plots
churn['Exited_str'] = churn['Exited']
churn['Exited_str'] = churn['Exited_str'].map({1: 'Exited', 0: 'Stayed'})

gender_count = churn['Gender'].value_counts()
gender_perct= gender_count / len(churn.index)

gender = pd.concat([gender_count, round(gender_perct,2)], axis=1)\
         .set_axis(['count', 'Perct'], axis=1)
gender

geo_count = churn['Geography'].value_counts()
geo_perct= geo_count / len(churn.index)

geo = pd.concat([geo_count, round(geo_perct,2)], axis=1)\
        .set_axis(['count', 'Perct'], axis=1)
geo

"""In the dataset, there are more men (55%) than women (45%), and it has only 3 different countries: France, Spain, and Germany. Where 50% of the customers are from France and 25% are from Germany, and the other group are from Spain.

Now, let's just check the relationship between the features and the outcome ('Exited').



"""

def count_by_group(data, feature, target):
    df = data.groupby([feature, target])[target].agg(['count'])
    temp = data.groupby([feature])[target].agg(['count'])
    df['Perct'] = 100*df.div(temp, level = feature).reset_index()['count'].values
    return df.reset_index()

count_by_group(churn, feature = 'Gender', target = 'Exited')

count_by_group(churn, feature = 'Geography', target = 'Exited')

HasCrCard_count = churn['HasCrCard'].value_counts()
HasCrCard_pct= HasCrCard_count / len(churn.index)

HasCrCard = pd.concat([HasCrCard_count, HasCrCard_pct], axis=1)\
        .set_axis(['count', 'Perct'], axis=1)

HasCrCard

count_by_group(churn, feature = 'HasCrCard', target = 'Exited')

NumOfProducts_count = churn['NumOfProducts'].value_counts()
NumOfProducts_pct= NumOfProducts_count / len(churn.index)

NumOfProducts = pd.concat([NumOfProducts_count, round(NumOfProducts_pct,2)], axis=1)\
        .set_axis(['count', 'Perct'], axis=1)
NumOfProducts

count_by_group(churn, feature = 'NumOfProducts', target = 'Exited')

"""# Data Visualisations"""

sns.countplot(data=churn,x='Gender',palette=['#FFD700', '#8E388E'])
plt.show()

sns.countplot(data=churn,x='Geography',palette = ['#FFD700', '#8E388E','blue'])
plt.show()

sns.countplot(data=churn,x='HasCrCard',palette = ['#FFD700', 'green'])
plt.show()

sns.countplot(data=churn,x='IsActiveMember',palette = ['skyblue', 'orange'])
plt.show()

sns.countplot(data=churn,x='Exited',palette = ['pink', '#8E388E'])
plt.show()

# Histogram of Age
plt.hist(churn['Age'],bins=30,color='green',edgecolor='black')
plt.title("Distribution of Age")
plt.xlabel("Age")
plt.ylabel("Frequency")
plt.show()

# Histogram of Age
plt.hist(churn['CreditScore'],bins=30,color='orange',edgecolor='red')
plt.title("Distribution of CreditScore")
plt.xlabel("CreditScore")
plt.ylabel("Frequency")
plt.show()

# Histogram of Age
plt.hist(churn['Balance'],bins=30,color='yellow',edgecolor='red')
plt.title("Distribution of Balance")
plt.xlabel("Balance")
plt.ylabel("Frequency")
plt.show()

# Histogram of Age
plt.hist(churn['EstimatedSalary'],bins=30,edgecolor='black')
plt.title("Distribution of Estimated Salary")
plt.xlabel("Salary")
plt.ylabel("Frequency")
plt.show()

"""- Some more Visualisations"""

ct = pd.crosstab(churn['Gender'], churn['Exited_str'])

gc=ct.plot(
    kind='bar',
    stacked=True,
    figsize=(6,4),
    color=['grey', 'green']
)

gc.legend(title=None)

plt.title('Gender vs Customer Status')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.show()

ct = pd.crosstab(churn['Geography'], churn['Exited_str'])

gc=ct.plot(
    kind='bar',
    stacked=True,
    figsize=(6,4),
    color=['grey', 'green']
)

gc.legend(title=None)

plt.title('Geography vs Customer Status')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.show()

ct = pd.crosstab(churn['HasCrCard'], churn['Exited_str'])

gc=ct.plot(
    kind='bar',
    stacked=True,
    figsize=(6,4),
    color=['grey', 'green']
)

gc.legend(title=None)

plt.title('Credit Card Ownership vs Customer Status')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.show()

ct = pd.crosstab(churn['IsActiveMember'], churn['Exited_str'])

gc=ct.plot(
    kind='bar',
    stacked=True,
    figsize=(6,4),
    color=['grey', 'green']
)

gc.legend(title=None)

plt.title('Activity vs Customer Status')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.show()

ct = pd.crosstab(churn['NumOfProducts'], churn['Exited_str'])

gc=ct.plot(
    kind='bar',
    stacked=True,
    figsize=(6,4),
    color=['grey', 'green']
)

gc.legend(title=None)

plt.title('Products  vs Customer Status')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.show()

#Stacked histogram: Age
figure = plt.figure(figsize=(17,10))
plt.hist([
        churn[(churn.Exited==0)]['Age'],
        churn[(churn.Exited==1)]['Age']
        ],
         stacked=True, color = ['green','grey'],
         bins = 'auto',label = ['Stayed','Exited'],
         edgecolor='black', linewidth=1.2)
plt.xlabel('Age (years)')
plt.ylabel('Number of customers')
plt.legend()

fig, axes = plt.subplots(nrows=2, ncols=2, figsize = (15,15))
fig.subplots_adjust(left=0.2, wspace=0.6)
ax0, ax1, ax2, ax3 = axes.flatten()

ax0.hist([
        churn[(churn.Exited==0)]['CreditScore'],
        churn[(churn.Exited==1)]['CreditScore']
        ],
         stacked=True, color = ['green','grey'],
         bins = 'auto', label = ['Stayed','Exited'],
         edgecolor='black', linewidth=1.2)
ax0.legend()
ax0.set_title('Credit Score')

ax1.hist([
        churn[(churn.Exited==0)]['Tenure'],
        churn[(churn.Exited==1)]['Tenure']
        ],
         stacked=True, color = ['green','grey'],
         bins = 'auto', label = ['Stayed','Exited'],
         edgecolor='black', linewidth=1.2)
ax1.legend()
ax1.set_title('Tenure')

ax2.hist([
        churn[(churn.Exited==0)]['Balance'],
        churn[(churn.Exited==1)]['Balance']
        ],
         stacked=True, color = ['green','grey'],
         bins = 'auto', label = ['Stayed','Exited'],
         edgecolor='black', linewidth=1.2)
ax2.legend()
ax2.set_title('Balance')

ax3.hist([
        churn[(churn.Exited==0)]['EstimatedSalary'],
        churn[(churn.Exited==1)]['EstimatedSalary']
        ],
         stacked=True, color = ['green','grey'],
         bins = 'auto', label = ['Stayed','Exited'],
         edgecolor='black', linewidth=1.2)
ax3.legend()
ax3.set_title('Estimated Salary')

fig.tight_layout()
plt.show()

"""## Insights from Tables and Plots

1. **Gender**  
   Women are fewer in number compared to men, but they show a **higher churn rate**, meaning a larger proportion of women tend to close their accounts.

2. **Geography**  
   Germany has the **highest churn rate (~32%)**, which is almost **twice** that of Spain and France.  
   Spain and France show relatively **lower churn rates (~16%)**.

3. **Age**  
   Customers **below 40 years** and **above 65 years** tend to **retain their accounts**, whereas middle-aged customers show a higher tendency to churn.

4. **Credit Card Ownership**  
   Having or not having a credit card **does not significantly impact churn**, as both groups show around **20% exited customers**.

5. **Activity Status**  
   **Inactive members** are more likely to discontinue banking services compared to active members  
   (**27% churn rate vs 14%**).

6. **Number of Products**  
   Around **96% of customers have only 1 or 2 products**.  
   Customers with **only 1 product** show a **much higher churn rate**, nearly **3 times higher** than customers with 2 products.

7. **Estimated Salary**  
   Estimated salary **does not show a noticeable impact** on customer churn.

- Dropping Irrelevant Features
"""

churn.columns

churn = churn.drop(['RowNumber', 'CustomerId', 'Surname','Exited_str'],axis=1)

churn.head()

"""- Encoding Categorical Data"""

churn['Geography'].unique()

churn= pd.get_dummies(churn,drop_first=True,dtype=int)

churn.head()

"""# Not Handling Imbalanced"""

churn['Exited'].value_counts()

X = churn.drop('Exited',axis=1)
y = churn['Exited']

"""#  Handling Imbalanced Data With SMOTE"""

from imblearn.over_sampling import SMOTE

X_res,y_res = SMOTE().fit_resample(X,y)

y_res.value_counts()

"""# Splitting The Dataset Into The Training Set And Test Set"""

from sklearn.model_selection import train_test_split

X_train,X_test,y_train,y_test=train_test_split(X_res,y_res,test_size=0.20,random_state=42)

"""# Feature Scaling"""

from sklearn.preprocessing import StandardScaler

sc= StandardScaler()

X_train=sc.fit_transform(X_train)
X_test = sc.transform(X_test)

X_train

"""# Training the Model"""

from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import GradientBoostingClassifier as GBSklearn
from xgboost import XGBClassifier as XGB
import lightgbm as lgb
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Evaluation function
def evaluate_model(y_true, y_pred):
    accuracy = accuracy_score(y_true, y_pred)
    precision = precision_score(y_true, y_pred)
    recall = recall_score(y_true, y_pred)
    f1 = f1_score(y_true, y_pred)
    return accuracy, precision, recall, f1

test_accuracy = []
model_names = []

## Beginning Model Training
models = {
    "Logistic Regression": LogisticRegression(),
    "Gradient Boosting Classifier": GBSklearn(),
    "XGBoost Classifier": XGB(),
    "LightGBM Classifier": lgb.LGBMClassifier(verbose=-1),
    "Random Forest Classifier": RandomForestClassifier()
}

for i in range(len(list(models))):
    model = list(models.values())[i]
    model.fit(X_train, y_train) # Train model

    # Make predictions
    y_train_pred = model.predict(X_train)
    y_test_pred = model.predict(X_test)

    # Evaluate Train and Test dataset
    accuracy_train_score , precision_train_score, recall_train_score,f1_train_score = evaluate_model(y_train, y_train_pred)
    accuracy_test_score , precision_test_score, recall_test_score,f1_test_score = evaluate_model(y_test, y_test_pred)

    # store values for plotting
    test_accuracy.append(accuracy_test_score * 100)
    model_names.append(list(models.keys())[i])

    print(list(models.keys())[i])
    print('Model Score for Training set')
    print("- accuracy_score: {:.4f}".format( accuracy_train_score ))
    print("- precision_score: {:.4f}".format(precision_train_score))
    print("- recall_score: {:.4f}".format( recall_train_score))
    print("- f1_score: {:.4f}".format( f1_train_score))
    print('----------------------------------')
    print('Model Score for Test set')
    print("- accuracy_score: {:.4f}".format( accuracy_test_score ))
    print("- precision_score: {:.4f}".format(precision_test_score))
    print("- recall_score: {:.4f}".format( recall_test_score))
    print("- f1_score: {:.4f}".format( f1_test_score))
    print('='*35)
    print('\n')

# Create final DataFrame
final_data = pd.DataFrame({
    'Models': model_names,
    'Accuracy': test_accuracy
})

final_data

plt.figure(figsize=(6, 5))
ax = sns.barplot(x=final_data['Models'], y=final_data['Accuracy'], palette=['blue', 'green', 'red','orange','purple'])

for i, v in enumerate(final_data['Accuracy']):
    ax.text(i, v + 1, f"{v:.2f}%", ha='center')

    # Add model name inside each bar rotated 90 degrees vertically with white background
    ax.text(i, v/2, final_data['Models'][i], ha='center', va='center',
            rotation=90, bbox=dict(boxstyle='round,pad=0.3', facecolor='white', alpha=0.9, edgecolor='none'),
            fontsize=9, fontweight='bold')

plt.ylabel('Accuracy (%)')
ax.set_xticklabels([])  # Remove x-axis labels

plt.ylim(0, 100)
plt.show()



















